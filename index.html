<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 탐색 알고리즘 시뮬레이터</title>
    <style>
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --background-color: #f8f9fa;
            --node-color: #fff;
            --node-border: #6c757d;
            --start-color: #28a745;
            --goal-color: #dc3545;
            --visited-color: #ffc107;
            --current-color: #17a2b8;
            --path-color: #007bff;
            --text-color: #212529;
            --light-text-color: #f8f9fa;
            --border-color: #dee2e6;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: var(--primary-color);
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            width: 100%;
            max-width: 1200px;
            gap: 20px;
        }

        .controls, .heuristics {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex: 1; 
        }

        .visualization {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex: 3; 
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #graph-svg {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            width: 100%;
            height: auto;
            aspect-ratio: 16 / 10;
            cursor: default;
        }

        #graph-svg .node {
            cursor: grab;
        }
        #graph-svg .node.dragging {
            cursor: grabbing;
        }
        
        .controls h2, .heuristics h2 {
            margin-top: 0;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group p.info {
            font-size: 14px;
            color: #555;
            background-color: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid var(--primary-color);
            line-height: 1.6;
        }
        
        .control-group p.info strong {
            display: inline-block;
            min-width: 80px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        select, button {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid var(--border-color);
            font-size: 16px;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #0056b3;
        }
        
        button:disabled {
            background-color: var(--secondary-color);
            cursor: not-allowed;
        }

        #clear-btn {
            background-color: var(--warning-color);
            color: #212529;
        }
        #clear-btn:hover {
            background-color: #e0a800;
        }

        #reset-btn {
            background-color: var(--secondary-color);
        }
        #reset-btn:hover {
            background-color: #5a6268;
        }

        #log {
            margin-top: 20px;
            width: 100%;
            height: 150px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 10px;
            overflow-y: auto;
            background-color: #f8f9fa;
        }
        #log p {
            margin: 0 0 5px 0;
            font-size: 14px;
        }

        .heuristic-input {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .heuristic-input label {
            flex: 1;
            margin-bottom: 0;
        }

        .heuristic-input input {
            width: 60px;
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            text-align: center;
        }

        footer {
            width: 100%;
            text-align: center;
            margin-top: 20px;
            padding: 20px 0;
            color: var(--secondary-color);
            border-top: 1px solid var(--border-color);
        }

        /* SVG Styles */
        .edge { stroke: #999; stroke-width: 2; }
        .edge-cost { 
            fill: #555; 
            font-size: 16px; 
            text-anchor: middle; 
            paint-order: stroke;
            stroke: #ffffff;
            stroke-width: 3px;
        }
        .node circle {
            stroke: var(--node-border);
            stroke-width: 2;
            fill: var(--node-color);
            transition: fill 0.3s, stroke 0.3s;
        }
        .node text {
            text-anchor: middle;
            font-size: 20px;
            font-weight: bold;
            fill: var(--text-color);
            pointer-events: none;
        }
        .node .heuristic-text {
            font-size: 16px;
            fill: var(--primary-color);
        }
        
        .node.start circle { fill: var(--start-color); stroke: #1e7e34;}
        .node.goal circle { fill: var(--goal-color); stroke: #b21f2d;}
        .node.start text, .node.goal text { fill: var(--light-text-color); }
        .node.visited circle { fill: var(--visited-color); }
        .node.current circle { fill: var(--current-color); transform: scale(1.1); }
        .node.path circle { fill: var(--path-color); }
        .edge.path { stroke: var(--path-color); stroke-width: 4; }

    </style>
</head>
<body>

    <h1>인공지능(AI) 탐색 알고리즘 시뮬레이터 🤖</h1>

    <div class="container">
        <div class="controls">
            <h2>✅ 사용 안내 및 설정</h2>
            <div class="control-group">
                <p class="info">
                    <strong>노드 이동</strong>: 드래그<br>
                    <strong>노드 추가</strong>: Alt + 빈 공간 클릭<br>
                    <strong>노드 삭제</strong>: Alt + Shift + 클릭<br>
                    <strong>간선 추가</strong>: Shift + 클릭 → 클릭<br>
                    <strong>간선 삭제</strong>: Ctrl + 클릭 → 클릭
                </p>
                <p><strong>시작점:</strong> <span id="start-node-display">없음</span></p>
                <p><strong>도착점:</strong> <span id="goal-node-display">없음</span></p>
            </div>
            <div class="control-group">
                <label for="algorithm-select"><strong>알고리즘 선택:</strong></label>
                <select id="algorithm-select">
                    <option value="bfs">너비 우선 탐색 (BFS)</option>
                    <option value="dfs">깊이 우선 탐색 (DFS)</option>
                    <option value="greedy">휴리스틱 우선 탐색 (Greedy)</option>
                    <option value="astar">A* 탐색</option>
                </select>
            </div>
            <div class="control-group">
                <button id="start-btn"><strong>탐색 시작</strong></button>
            </div>
             <div class="control-group">
                <button id="clear-btn">탐색 결과 지우기</button>
            </div>
             <div class="control-group">
                <button id="reset-btn">새로운 그래프 만들기</button>
            </div>
        </div>

        <div class="visualization">
            <svg id="graph-svg" viewBox="0 0 800 500"></svg>
            <div id="log-container">
                <h3>탐색 과정 로그</h3>
                <div id="log"></div>
            </div>
        </div>
        
        <div class="heuristics">
            <h2>휴리스틱 값 설정</h2>
            <p>직접 값을 수정할 수 있습니다.</p>
            <div id="heuristic-inputs"></div>
        </div>
    </div>

    <footer>
        <p>만든이 by 깐깐샘(2025. 9. 18. 수정)</p>
    </footer>

    <script>
        const svg = document.getElementById('graph-svg');
        const algorithmSelect = document.getElementById('algorithm-select');
        const startBtn = document.getElementById('start-btn');
        const clearBtn = document.getElementById('clear-btn');
        const resetBtn = document.getElementById('reset-btn');
        const startNodeDisplay = document.getElementById('start-node-display');
        const goalNodeDisplay = document.getElementById('goal-node-display');
        const log = document.getElementById('log');
        const heuristicInputsContainer = document.getElementById('heuristic-inputs');
        const heuristicsPanel = document.querySelector('.heuristics');

        let graphData = { nodes: {}, edges: [] };
        let startNode = null;
        let goalNode = null;
        let isRunning = false;
        
        let selectedNode = null;
        let offset = { x: 0, y: 0 };
        let wasDragged = false;
        let currentInteractionMode = 'none';
        let firstNodeForConnection = null;

        function generateRandomGraph() {
            // [수정] 노드 개수를 5 또는 6으로 설정
            const numNodes = Math.floor(Math.random() * 2) + 5; 
            const newNodes = {};
            const newEdges = [];
            const nodeIds = [];
            const viewWidth = 800;
            const viewHeight = 500;
            const padding = 80;

            for (let i = 0; i < numNodes; i++) {
                const nodeId = String.fromCharCode(65 + i);
                nodeIds.push(nodeId);
                let x, y, tooClose;
                do {
                    tooClose = false;
                    x = Math.floor(Math.random() * (viewWidth - padding * 2)) + padding;
                    y = Math.floor(Math.random() * (viewHeight - padding * 2)) + padding;
                    for (const id in newNodes) {
                        const d = Math.sqrt(Math.pow(newNodes[id].x - x, 2) + Math.pow(newNodes[id].y - y, 2));
                        if (d < 120) { tooClose = true; break; }
                    }
                } while (tooClose);
                newNodes[nodeId] = { x, y, h: 0 };
            }

            if (numNodes > 0) {
                const goalRefId = nodeIds[numNodes - 1];
                const goalRefNode = newNodes[goalRefId];
                for (const id in newNodes) {
                    const node = newNodes[id];
                    const distance = Math.sqrt(Math.pow(node.x - goalRefNode.x, 2) + Math.pow(node.y - goalRefNode.y, 2));
                    node.h = Math.round(distance / 30);
                }
            }
            
            for (let i = 0; i < numNodes; i++) {
                const fromNode = nodeIds[i];
                const toNode = nodeIds[(i + 1) % numNodes];
                newEdges.push({ from: fromNode, to: toNode, cost: Math.floor(Math.random() * 15) + 1 });
            }
            const extraEdges = Math.floor(numNodes / 2);
            for (let i = 0; i < extraEdges; i++) {
                const nodeA = nodeIds[Math.floor(Math.random() * numNodes)];
                const nodeB = nodeIds[Math.floor(Math.random() * numNodes)];
                if (nodeA !== nodeB) {
                    const edgeExists = newEdges.some(e => (e.from === nodeA && e.to === nodeB) || (e.from === nodeB && e.to === nodeA));
                    const areAdjacentInCycle = Math.abs(nodeIds.indexOf(nodeA) - nodeIds.indexOf(nodeB)) % (numNodes - 1) === 1;
                    if (!edgeExists && !areAdjacentInCycle) {
                        newEdges.push({ from: nodeA, to: nodeB, cost: Math.floor(Math.random() * 15) + 1 });
                    }
                }
            }
            graphData = { nodes: newNodes, edges: newEdges };
        }

        function logMessage(message) { 
            log.innerHTML += `<p>${message}</p>`; 
            log.scrollTop = log.scrollHeight; 
        }
        
        function updateNodeClass(nodeId, className, add = true) { 
            const nodeElement = document.getElementById(`node-${nodeId}`); 
            if (nodeElement) { 
                if (add) nodeElement.classList.add(className); 
                else nodeElement.classList.remove(className); 
            } 
        }
        
        function updateEdgeClass(from, to, className, add = true) { 
            const edgeId = [from, to].sort().join('-'); 
            const edgeElement = document.getElementById(`edge-${edgeId}`); 
            if(edgeElement) { 
                if (add) edgeElement.classList.add(className); 
                else edgeElement.classList.remove(className); 
            } 
        }

        function sleep(ms) { 
            return new Promise(resolve => setTimeout(resolve, ms)); 
        }

        function drawGraph() {
            svg.innerHTML = '';
            
            graphData.edges.forEach(({ from, to, cost }) => {
                const nodeFrom = graphData.nodes[from]; 
                const nodeTo = graphData.nodes[to];
                if (!nodeFrom || !nodeTo) return;
                const edgeId = [from, to].sort().join('-');
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('id', `edge-${edgeId}`); 
                line.setAttribute('x1', nodeFrom.x); 
                line.setAttribute('y1', nodeFrom.y); 
                line.setAttribute('x2', nodeTo.x); 
                line.setAttribute('y2', nodeTo.y); 
                line.classList.add('edge');
                svg.appendChild(line);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                const midX = (nodeFrom.x + nodeTo.x) / 2; 
                const midY = (nodeFrom.y + nodeTo.y) / 2;
                const angle = Math.atan2(nodeTo.y - nodeFrom.y, nodeTo.x - nodeFrom.x); 
                const offset = 15;
                text.setAttribute('x', midX + offset * Math.sin(angle)); 
                text.setAttribute('y', midY - offset * Math.cos(angle));
                text.textContent = cost; 
                text.classList.add('edge-cost'); 
                svg.appendChild(text);
            });

            Object.keys(graphData.nodes).forEach(id => {
                const { x, y, h } = graphData.nodes[id];
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('id', `node-${id}`); 
                g.classList.add('node'); 
                g.setAttribute('transform', `translate(${x},${y})`);
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); 
                circle.setAttribute('r', 30);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text'); 
                text.setAttribute('y', 7); 
                text.textContent = id;
                
                const heuristicText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                heuristicText.setAttribute('id', `h-text-${id}`); 
                heuristicText.setAttribute('y', 50); 
                heuristicText.classList.add('heuristic-text'); 
                heuristicText.textContent = `h=${h}`;
                
                g.appendChild(circle); 
                g.appendChild(text); 
                g.appendChild(heuristicText); 
                svg.appendChild(g);
                g.addEventListener('mousedown', (e) => handleNodeMouseDown(e, id));
            });
        }
        
        startBtn.addEventListener('click', () => {
            if (!startNode || !goalNode) { 
                alert('시작 노드와 도착 노드를 모두 선택해주세요.'); 
                return; 
            }
            if(isRunning) return;
            reset(false);
            isRunning = true;
            startBtn.disabled = true; 
            clearBtn.disabled = true; 
            resetBtn.disabled = true;
            const selectedAlgorithm = algorithmSelect.value;
            let promise;
            if (selectedAlgorithm === 'bfs') promise = bfs(); 
            else if (selectedAlgorithm === 'dfs') promise = dfs();
            else if (selectedAlgorithm === 'greedy') promise = greedy(); 
            else if (selectedAlgorithm === 'astar') promise = astar();
            
            promise.finally(() => {
                isRunning = false;
                startBtn.disabled = false; 
                clearBtn.disabled = false; 
                resetBtn.disabled = false;
            });
        });
        
        clearBtn.addEventListener('click', () => reset(false));
        resetBtn.addEventListener('click', () => reset(true));

        algorithmSelect.addEventListener('change', (e) => {
            const selected = e.target.value;
            if (selected === 'greedy' || selected === 'astar') {
                heuristicsPanel.style.display = 'block';
            } else {
                heuristicsPanel.style.display = 'none';
            }
        });

        function getMousePosition(evt) { 
            const CTM = svg.getScreenCTM(); 
            return { 
                x: (evt.clientX - CTM.e) / CTM.a, 
                y: (evt.clientY - CTM.f) / CTM.d 
            }; 
        }

        function handleNodeMouseDown(e, nodeId) {
            e.preventDefault(); 
            e.stopPropagation(); 
            if (isRunning) return;
            wasDragged = false;
            if (e.altKey || e.shiftKey || e.ctrlKey || e.metaKey) return;
            
            selectedNode = document.getElementById(`node-${nodeId}`);
            selectedNode.classList.add('dragging');
            const pos = getMousePosition(e); 
            const { x, y } = graphData.nodes[nodeId];
            offset = { x: pos.x - x, y: pos.y - y };
        }

        function handleGlobalMouseMove(e) {
            if (!selectedNode || isRunning) return;
            wasDragged = true;
            const pos = getMousePosition(e);
            const nodeId = selectedNode.id.replace('node-', '');
            const newX = pos.x - offset.x; 
            const newY = pos.y - offset.y;
            graphData.nodes[nodeId].x = newX; 
            graphData.nodes[nodeId].y = newY;
            selectedNode.setAttribute('transform', `translate(${newX},${newY})`);
            updateConnectedEdges(nodeId, newX, newY);
        }

        function handleGlobalMouseUp(e) {
            if (selectedNode) {
                selectedNode.classList.remove('dragging');
                if (wasDragged) { 
                    drawGraph(); 
                    reset(false); 
                }
            }
            selectedNode = null;
            setTimeout(() => { wasDragged = false; }, 0);
        }

        svg.addEventListener('click', (e) => {
            if (isRunning) return;
            const nodeElement = e.target.closest('.node');

            if (nodeElement) {
                const nodeId = nodeElement.id.replace('node-', '');
                if (wasDragged) return;

                if (e.altKey && e.shiftKey) { 
                    deleteNode(nodeId); 
                    return; 
                }
                
                if (e.shiftKey) { 
                    currentInteractionMode = 'addingEdge'; 
                } else if (e.ctrlKey || e.metaKey) { 
                    currentInteractionMode = 'deletingEdge'; 
                }

                if (currentInteractionMode !== 'none') {
                    if (!firstNodeForConnection) {
                        firstNodeForConnection = nodeId;
                    } else {
                        if (firstNodeForConnection !== nodeId) {
                            if (currentInteractionMode === 'addingEdge') addEdge(firstNodeForConnection, nodeId);
                            else deleteEdge(firstNodeForConnection, nodeId);
                        }
                        firstNodeForConnection = null;
                        currentInteractionMode = 'none';
                    }
                } else {
                    handleStartGoalSelection(nodeId);
                }
            } else {
                if (e.altKey && !e.shiftKey) {
                    const pos = getMousePosition(e);
                    addNode(pos.x, pos.y);
                }
                firstNodeForConnection = null;
                currentInteractionMode = 'none';
            }
        });
        
        function handleStartGoalSelection(nodeId) {
            reset(false);
            if (!startNode) {
                startNode = nodeId; 
                updateNodeClass(nodeId, 'start'); 
                startNodeDisplay.textContent = nodeId;
            } else if (!goalNode && nodeId !== startNode) {
                goalNode = nodeId; 
                updateNodeClass(nodeId, 'goal'); 
                goalNodeDisplay.textContent = nodeId;
            } else if (nodeId === startNode) {
                updateNodeClass(startNode, 'start', false); 
                startNode = null; 
                startNodeDisplay.textContent = '없음';
            } else if (nodeId === goalNode) {
                updateNodeClass(goalNode, 'goal', false); 
                goalNode = null; 
                goalNodeDisplay.textContent = '없음';
            }
        }

        function deleteNode(nodeId) {
            delete graphData.nodes[nodeId];
            graphData.edges = graphData.edges.filter(edge => edge.from !== nodeId && edge.to !== nodeId);
            if (startNode === nodeId) { 
                startNode = null; 
                startNodeDisplay.textContent = '없음'; 
            }
            if (goalNode === nodeId) { 
                goalNode = null; 
                goalNodeDisplay.textContent = '없음'; 
            }
            drawGraph(); 
            createHeuristicInputs(); 
            reset(false);
        }

        svg.addEventListener('mousemove', handleGlobalMouseMove);
        svg.addEventListener('mouseup', handleGlobalMouseUp);
        svg.addEventListener('mouseleave', handleGlobalMouseUp);

        algorithmSelect.dispatchEvent(new Event('change'));
        reset(true);
        
        function createHeuristicInputs() {
            heuristicInputsContainer.innerHTML = '';
            Object.keys(graphData.nodes).forEach(id => {
                const div = document.createElement('div'); 
                div.classList.add('heuristic-input');
                const label = document.createElement('label'); 
                label.setAttribute('for', `h-input-${id}`); 
                label.textContent = `노드 ${id}의 h(n) 값:`;
                const input = document.createElement('input'); 
                input.type = 'number'; 
                input.id = `h-input-${id}`; 
                input.value = graphData.nodes[id].h; 
                input.min = 0; 
                input.max = 999;
                input.addEventListener('change', (e) => {
                    let newValue = parseInt(e.target.value, 10);
                    if (!isNaN(newValue)) {
                        newValue = Math.max(0, newValue); 
                        e.target.value = newValue;
                        graphData.nodes[id].h = newValue;
                        document.getElementById(`h-text-${id}`).textContent = `h=${newValue}`;
                    }
                });
                div.appendChild(label); 
                div.appendChild(input); 
                heuristicInputsContainer.appendChild(div);
            });
        }
        
        async function reconstructPath(cameFrom, current, visitedOrder) {
            let totalCost = 0;
            const path = [];
            let temp = current;
            while(temp) {
                path.unshift(temp);
                const parent = cameFrom[temp]?.node;
                if(parent) {
                    const edge = graphData.edges.find(e => (e.from === parent && e.to === temp) || (e.from === temp && e.to === parent));
                    if(edge) totalCost += edge.cost;
                }
                temp = parent;
            }
            logMessage(`➡️ 방문 노드 순서: ${visitedOrder.join(' → ')}`);
            logMessage(`✅ 최종 경로: ${path.join(' → ')}`);
            logMessage(`💰 총 비용: ${totalCost}`);
            for(let i=0; i < path.length; i++){
                updateNodeClass(path[i], 'path');
                if(i > 0){
                    updateEdgeClass(path[i-1], path[i], 'path');
                }
                await sleep(150);
            }
        }
        
        async function bfs() {
            logMessage("--- 너비 우선 탐색 (BFS) 시작 ---");
            let queue = [{node: startNode, path: [startNode]}];
            let visited = new Set([startNode]);
            const cameFrom = {[startNode]: null};
            const visitedOrder = [];

            while (queue.length > 0) {
                const { node: current } = queue.shift();
                visitedOrder.push(current);

                updateNodeClass(current, 'current');
                logMessage(`👀 방문 노드: ${current}`);
                await sleep(500);
                if (current === goalNode) {
                    logMessage("🎉 목표 노드에 도달했습니다!");
                    updateNodeClass(current, 'current', false);
                    await reconstructPath(cameFrom, current, visitedOrder);
                    return;
                }
                const neighbors = graphData.edges.filter(e => e.from === current || e.to === current).map(e => e.from === current ? e.to : e.from);
                for (const neighbor of neighbors) {
                    if (!visited.has(neighbor)) {
                        visited.add(neighbor);
                        cameFrom[neighbor] = {node: current};
                        queue.push({node: neighbor});
                        updateNodeClass(neighbor, 'visited');
                        logMessage(`  - 이웃 ${neighbor}를 대기큐에 추가`);
                    }
                }
                updateNodeClass(current, 'current', false);
                if(current !== startNode) updateNodeClass(current, 'visited');
            }
            logMessage("❌ 목표 노드를 찾지 못했습니다.");
        }
        
        async function dfs() {
            logMessage("--- 깊이 우선 탐색 (DFS) 시작 ---");
            let stack = [{node: startNode}];
            let visited = new Set();
            const cameFrom = {[startNode]: null};
            const visitedOrder = [];

            while (stack.length > 0) {
                const { node: current } = stack.pop();
                if (visited.has(current)) continue;
                
                visited.add(current);
                visitedOrder.push(current);

                updateNodeClass(current, 'current');
                logMessage(`👀 방문 노드: ${current}`);
                await sleep(500);

                if (current === goalNode) {
                    logMessage("🎉 목표 노드에 도달했습니다!");
                    updateNodeClass(current, 'current', false);
                    await reconstructPath(cameFrom, current, visitedOrder);
                    return;
                }
                const neighbors = graphData.edges.filter(e => e.from === current || e.to === current).map(e => e.from === current ? e.to : e.from).reverse();
                for (const neighbor of neighbors) {
                    if (!visited.has(neighbor)) {
                        stack.push({node: neighbor});
                        cameFrom[neighbor] = {node: current};
                        logMessage(`  - 이웃 ${neighbor}를 스택에 추가`);
                    }
                }
                if(current !== startNode) updateNodeClass(current, 'visited');
                updateNodeClass(current, 'current', false);
            }
            logMessage("❌ 목표 노드를 찾지 못했습니다.");
        }
        
        async function greedy() {
            logMessage("--- 휴리스틱 우선 탐색 (Greedy) 시작 ---");
            let openList = [{ node: startNode, h: graphData.nodes[startNode].h }];
            let visited = new Set();
            const cameFrom = { [startNode]: null };
            const visitedOrder = [];

            while (openList.length > 0) {
                openList.sort((a, b) => a.h - b.h);
                const { node: current } = openList.shift();
                if (visited.has(current)) continue;

                visited.add(current);
                visitedOrder.push(current);

                updateNodeClass(current, 'current');
                logMessage(`👀 방문 노드: ${current} (h=${graphData.nodes[current].h})`);
                await sleep(500);

                if (current === goalNode) {
                    logMessage("🎉 목표 노드에 도달했습니다!");
                    updateNodeClass(current, 'current', false);
                    await reconstructPath(cameFrom, current, visitedOrder);
                    return;
                }
                const neighbors = graphData.edges.filter(e => e.from === current || e.to === current).map(e => e.from === current ? e.to : e.from);
                for (const neighbor of neighbors) {
                    if (!visited.has(neighbor)) {
                        cameFrom[neighbor] = { node: current };
                        const neighborHeuristic = graphData.nodes[neighbor].h;
                        openList.push({ node: neighbor, h: neighborHeuristic });
                        updateNodeClass(neighbor, 'visited');
                        logMessage(`  - 이웃 ${neighbor}(h=${neighborHeuristic})를 목록에 추가`);
                    }
                }
                if(current !== startNode) updateNodeClass(current, 'visited');
                updateNodeClass(current, 'current', false);
            }
            logMessage("❌ 목표 노드를 찾지 못했습니다.");
        }

        async function astar() {
            logMessage("--- A* 탐색 시작 ---");
            let openList = [{ node: startNode, g: 0, h: graphData.nodes[startNode].h, f: graphData.nodes[startNode].h }];
            let cameFrom = { [startNode]: null };
            let gScore = {};
            Object.keys(graphData.nodes).forEach(node => gScore[node] = Infinity);
            gScore[startNode] = 0;
            const visitedOrder = [];
            const closedSet = new Set();

            while (openList.length > 0) {
                openList.sort((a, b) => a.f - b.f);
                const currentItem = openList.shift();
                const current = currentItem.node;

                if (closedSet.has(current)) continue;
                closedSet.add(current);
                visitedOrder.push(current);
                
                updateNodeClass(current, 'current');
                logMessage(`👀 방문 노드: ${current} (g=${currentItem.g}, h=${currentItem.h}, f=${currentItem.f})`);
                await sleep(500);

                if (current === goalNode) {
                    logMessage("🎉 목표 노드에 도달했습니다!");
                    updateNodeClass(current, 'current', false);
                    await reconstructPath(cameFrom, current, visitedOrder);
                    return;
                }
                if(current !== startNode) updateNodeClass(current, 'visited');
                const neighbors = graphData.edges.filter(e => e.from === current || e.to === current);
                for (const edge of neighbors) {
                    const neighbor = edge.from === current ? edge.to : edge.from;
                    const tentativeGScore = gScore[current] + edge.cost;
                    if (tentativeGScore < gScore[neighbor]) {
                        cameFrom[neighbor] = { node: current };
                        gScore[neighbor] = tentativeGScore;
                        const hScore = graphData.nodes[neighbor].h;
                        const fScore = tentativeGScore + hScore;
                        if (!openList.some(item => item.node === neighbor)) {
                            openList.push({ node: neighbor, g: tentativeGScore, h: hScore, f: fScore });
                            updateNodeClass(neighbor, 'visited');
                            logMessage(`  - 이웃 ${neighbor}(f=${fScore})를 목록에 추가`);
                        }
                    }
                }
                updateNodeClass(current, 'current', false);
            }
            logMessage("❌ 목표 노드를 찾지 못했습니다.");
        }
        
        function reset(fullReset = true) {
            log.innerHTML = '';
            Object.keys(graphData.nodes).forEach(id => {
                const nodeElement = document.getElementById(`node-${id}`);
                if (nodeElement) nodeElement.classList.remove('visited', 'current', 'path');
            });
            graphData.edges.forEach(({ from, to }) => updateEdgeClass(from, to, 'path', false));
            
            if (fullReset) {
                startNode = null; 
                goalNode = null;
                startNodeDisplay.textContent = '없음'; 
                goalNodeDisplay.textContent = '없음';
                Object.keys(graphData.nodes).forEach(id => {
                    updateNodeClass(id, 'start', false); 
                    updateNodeClass(id, 'goal', false);
                });
                generateRandomGraph();
                drawGraph();
                createHeuristicInputs();
                startBtn.disabled = false;
            } else {
                if(startNode) updateNodeClass(startNode, 'start');
                if(goalNode) updateNodeClass(goalNode, 'goal');
            }
        }
        
        function updateConnectedEdges(nodeId, newX, newY) {
            graphData.edges.forEach(({from, to}) => {
                if (from === nodeId || to === nodeId) {
                    const edgeId = [from, to].sort().join('-');
                    const edgeEl = document.getElementById(`edge-${edgeId}`);
                    if (edgeEl) {
                        if (from === nodeId) { 
                            edgeEl.setAttribute('x1', newX); 
                            edgeEl.setAttribute('y1', newY); 
                        } else { 
                            edgeEl.setAttribute('x2', newX); 
                            edgeEl.setAttribute('y2', newY); 
                        }
                        const costText = Array.from(edgeEl.parentNode.children).find(child => child.classList.contains('edge-cost') && child.previousSibling === edgeEl);
                        if(costText) {
                            const nodeFrom = graphData.nodes[from]; 
                            const nodeTo = graphData.nodes[to];
                            const midX = (nodeFrom.x + nodeTo.x) / 2; 
                            const midY = (nodeFrom.y + nodeTo.y) / 2;
                            const angle = Math.atan2(nodeTo.y - nodeFrom.y, nodeTo.x - nodeFrom.x); 
                            const textOffset = 15;
                            costText.setAttribute('x', midX + textOffset * Math.sin(angle));
                            costText.setAttribute('y', midY - textOffset * Math.cos(angle));
                        }
                    }
                }
            });
        }
        
        function addNode(x, y) {
            let nextChar = 'A';
            const existingIds = Object.keys(graphData.nodes);
            while (existingIds.includes(nextChar)) {
                nextChar = String.fromCharCode(nextChar.charCodeAt(0) + 1);
            }
            graphData.nodes[nextChar] = { x, y, h: 0 }; 
            const nodeIds = Object.keys(graphData.nodes); 
            if(nodeIds.length > 1) { 
                const goalRefId = goalNode || nodeIds.find(id => id !== nextChar); 
                const goalRefNode = graphData.nodes[goalRefId]; 
                if (goalRefNode) {
                    for(const id in graphData.nodes) { 
                        const node = graphData.nodes[id]; 
                        const distance = Math.sqrt(Math.pow(node.x - goalRefNode.x, 2) + Math.pow(node.y - goalRefNode.y, 2)); 
                        node.h = Math.round(distance / 30); 
                    } 
                }
            }
            drawGraph();
            createHeuristicInputs();
        }

        function addEdge(fromNode, toNode) {
            const edgeExists = graphData.edges.some(e => (e.from === fromNode && e.to === toNode) || (e.from === toNode && e.to === fromNode));
            if (edgeExists) { 
                alert("이미 간선이 존재합니다."); 
                return; 
            }
            const costStr = prompt(`'${fromNode}'와 '${toNode}'를 잇는 간선 비용(1-15)을 입력하세요:`, "8");
            if (costStr !== null) {
                const cost = parseInt(costStr, 10);
                if (!isNaN(cost) && cost >= 1 && cost <= 15) {
                    graphData.edges.push({ from: fromNode, to: toNode, cost: cost });
                    drawGraph();
                    reset(false);
                } else { 
                    alert("1부터 15 사이의 유효한 숫자를 입력해야 합니다."); 
                }
            }
        }
        
        function deleteEdge(node1, node2) {
            const edgeIndex = graphData.edges.findIndex(e => (e.from === node1 && e.to === node2) || (e.from === node2 && e.to === node1));
            if (edgeIndex > -1) {
                graphData.edges.splice(edgeIndex, 1);
                drawGraph();
                reset(false);
            } else { 
                alert("두 노드 사이에 간선이 존재하지 않습니다."); 
            }
        }
    </script>
</body>
</html>
